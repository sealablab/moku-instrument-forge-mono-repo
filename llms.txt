# moku-instrument-forge-mono-repo

> Hierarchical monorepo for developing Moku custom EMFI probe drivers

## What is this?

Monorepo orchestrating composable git submodules for the complete probe development workflow: type system → code generation → VHDL implementation → hardware deployment.

**Key insight:** Tiered documentation with submodule delegation enables focused context loading.

**Architecture:** v2.0.0 - Clean separation between tools and foundational libraries (flat structure)

## Repository Structure

### Development Tools (git submodules)

| Tool | Purpose | Quick Ref |
|------|---------|-----------|
| [forge-codegen](tools/forge-codegen/) | YAML → VHDL code generator with type-safe register serialization | [llms.txt](tools/forge-codegen/llms.txt) |

**Internal to forge-codegen:**
- `basic_serialized_datatypes/` - 23-type system (voltage/time/boolean) with automatic register packing
- Not a separate library, tightly coupled serialization internals

### Foundational Libraries (git submodules - flat structure)

Authoritative Pydantic model libraries defining core abstractions:

| Library | Purpose | Quick Ref |
|---------|---------|-----------|
| [forge-vhdl](libs/forge-vhdl/) | Reusable VHDL components + voltage type system | [llms.txt](libs/forge-vhdl/llms.txt) |
| [moku-models](libs/moku-models/) | Platform specifications (Go/Lab/Pro/Delta) | [llms.txt](libs/moku-models/llms.txt) |
| [riscure-models](libs/riscure-models/) | Probe hardware specs (DS1120A, voltage safety) | [llms.txt](libs/riscure-models/llms.txt) |

**Design Philosophy:**
- forge-vhdl: Practical VHDL utilities (3 voltage domains: 3.3V, 5V, ±5V)
- forge-codegen: Comprehensive code generation (23 types, auto register packing)
- Clean separation of concerns

**Voltage Type System:** Function-based voltage domain safety
- Design: [docs/migration/VOLTAGE_TYPE_SYSTEM_DESIGN.md](docs/migration/VOLTAGE_TYPE_SYSTEM_DESIGN.md)
- Python reference: [docs/migration/voltage_types_reference.py](docs/migration/voltage_types_reference.py)

## Common Workflows

### Type System Lookup
**Task:** "What voltage types are available?"
**→ Read:** [tools/forge-codegen/llms.txt](tools/forge-codegen/llms.txt) (section: "Basic Usage" → Type System)

### Platform Specs Lookup
**Task:** "What's Moku:Go clock frequency?"
**→ Read:** [libs/moku-models/llms.txt](libs/moku-models/llms.txt)

### Code Generation
**Task:** "Generate VHDL from YAML spec"
**→ Read:** [tools/forge-codegen/llms.txt](tools/forge-codegen/llms.txt)
**→ Entry point:** `python -m forge_codegen.generator.codegen spec.yaml`

### VHDL Component Usage
**Task:** "Use clock divider or voltage packages"
**→ Read:** [libs/forge-vhdl/llms.txt](libs/forge-vhdl/llms.txt)

### Platform Validation
**Task:** "Validate deployment config"
**→ Read:** [libs/moku-models/llms.txt](libs/moku-models/llms.txt)

### Voltage Safety Checking
**Task:** "Validate probe wiring compatibility"
**→ Read:** [libs/moku-models/llms.txt](libs/moku-models/llms.txt) + [libs/riscure-models/llms.txt](libs/riscure-models/llms.txt)

## Tiered Context Loading Strategy

### Tier 1: Quick Reference (Always load first)
**Files:** All llms.txt files (~150-200 lines each)
**Purpose:** Essential facts, API surface, common tasks
**When:** Every interaction - minimal token cost (~500-1000 tokens each)

**Load these first:**
- tools/forge-codegen/llms.txt
- libs/forge-vhdl/llms.txt
- libs/moku-models/llms.txt
- libs/riscure-models/llms.txt

### Tier 2: Deep Context (Load when designing/integrating)
**Files:** CLAUDE.md files (~3-5k tokens each)
**Purpose:** Design rationale, integration patterns, development workflows
**When:** Designing new features, understanding architecture

**Load when needed:**
- tools/forge-codegen/CLAUDE.md (code generation internals)
- libs/forge-vhdl/CLAUDE.md (VHDL design patterns, testing standards)
- libs/moku-models/CLAUDE.md (platform integration)
- libs/riscure-models/CLAUDE.md (probe specifications)

### Tier 3: Implementation (Load when modifying code)
**Files:** Agent prompts, source code, tests, specialized docs
**Purpose:** Detailed implementation logic
**When:** Actually writing/modifying code

**Load selectively:**
- .claude/agents/*/agent.md (monorepo orchestration agents)
- tools/forge-codegen/docs/ (detailed guides, references)
- Source files in specific submodules
- Test files for validation

## For AI Agents

### Context Decision Tree

**Question type** → **Load strategy**

"What types exist?" → Tier 1: tools/forge-codegen/llms.txt

"How do I add a new type?" → Tier 2: tools/forge-codegen/CLAUDE.md

"Generate VHDL from YAML" → Tier 1: tools/forge-codegen/llms.txt

"Use VHDL components" → Tier 1: libs/forge-vhdl/llms.txt

"Platform compatibility?" → Tier 1: libs/moku-models/llms.txt

"Probe voltage safety?" → Tier 1: libs/moku-models/llms.txt + libs/riscure-models/llms.txt

### Authoritative Sources

**Always trust these libraries:**
- Type definitions → tools/forge-codegen (23 types internally, no guessing!)
- Platform specs → libs/moku-models (Go/Lab/Pro/Delta hardware specs)
- Probe specs → libs/riscure-models (DS1120A voltage ranges)
- VHDL utilities → libs/forge-vhdl (3 voltage domains, CocoTB tested)

**Never:**
- Infer types that don't exist
- Guess platform clock frequencies
- Assume voltage compatibility without validation
- Use enums for FSM states (Verilog incompatible!)

### Agent Delegation

**Monorepo-level coordination (.claude/):**
- deployment-orchestrator - Hardware deployment workflows
- hardware-debug - FSM debugging expertise
- probe-design-orchestrator - Multi-stage workflows

**Delegation principle:**
- Monorepo agents coordinate
- Submodule work happens within submodules
- Clear boundaries, no duplication

## Key Design Principles

1. **Clean Separation (v2.0)** - tools/ vs libs/ (no nested submodules)
2. **Tiered docs** - llms.txt (quick ref) → CLAUDE.md (deep dive) → source
3. **Agent delegation** - Monorepo coordinates, submodules execute
4. **Single source of truth** - Each submodule is authoritative for its domain
5. **Context efficiency** - Load minimally, expand as needed
6. **Type safety throughout** - Pydantic validation, voltage domain safety

## Development Notes

### Git Submodule Workflow

```bash
# Initialize all submodules
git submodule update --init --recursive

# Update specific submodule
cd libs/moku-models
git pull origin main
cd ../..
git add libs/moku-models
git commit -m "Update moku-models submodule"

# Push both submodule and parent
git push
```

### Quick Start

```bash
# Clone with submodules
git clone --recurse-submodules https://github.com/sealablab/moku-instrument-forge-mono-repo.git

# Setup Python environment
uv sync

# Run tests
pytest
```

## Quick Links

### Documentation
- **Architecture overview:** [.claude/shared/ARCHITECTURE_OVERVIEW.md](.claude/shared/ARCHITECTURE_OVERVIEW.md) (v2.0)
- **Migration history:** [ARCHITECTURE_V2_COMPLETE.md](ARCHITECTURE_V2_COMPLETE.md)
- **Workflow guide:** [WORKFLOW_GUIDE.md](WORKFLOW_GUIDE.md)
- **Voltage type system:** [docs/migration/VOLTAGE_TYPE_SYSTEM_DESIGN.md](docs/migration/VOLTAGE_TYPE_SYSTEM_DESIGN.md)

### Agents
- **Monorepo agents:** [.claude/agents/](.claude/agents/) (deployment, hardware-debug, probe-design)

### Submodule Context
- **forge-codegen:** [llms.txt](tools/forge-codegen/llms.txt) | [CLAUDE.md](tools/forge-codegen/CLAUDE.md)
- **forge-vhdl:** [llms.txt](libs/forge-vhdl/llms.txt) | [CLAUDE.md](libs/forge-vhdl/CLAUDE.md)
- **moku-models:** [llms.txt](libs/moku-models/llms.txt) | [CLAUDE.md](libs/moku-models/CLAUDE.md)
- **riscure-models:** [llms.txt](libs/riscure-models/llms.txt) | [CLAUDE.md](libs/riscure-models/CLAUDE.md)

---

**Version:** v2.0.0
**Last Updated:** 2025-11-04
**Architecture:** Clean separation (tools + flat libs)
**Main Branch:** main
**License:** MIT
